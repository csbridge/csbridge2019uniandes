<head>

	%include templates/parts/head.html
<style media="screen" type="text/css">
  #console {
    overflow: hide;
    border: solid 1px black;
    background-color: white;
    width: 500px;
    height: 300px;
  }
</style></head><body><!-- Navigation Bar -->
	%include templates/parts/navBarEs.html
<!-- Main Content --><div class="container"><!-- Header --><div id="pageHeader"><h1> Antiguo juego de nimm </h1><p> Problema escrito por Danielle Kain y Chris Piech. </p><p> Ejemplos trabajados: <a href="{{pathToRoot}}es/projects/emc2.html">E = MC2</a>, <a href="{{pathToRoot}}es/projects/fibb.html">Fibbonacci</a></p></div><hr/><div class="row"><div class="col-md-12"><p> Nimm es un antiguo juego de estrategia que lleva el nombre de la antigua palabra alemana para &quot;tomar&quot;. También se llama Tiouk Tiouk en África occidental y Tsynshidzi en China. Los jugadores se alternan tomando piedras hasta que quedan cero. El juego de Nimm es el siguiente: <ol><li> El juego comienza con una pila de 20 piedras entre los jugadores. </li><li> Los dos jugadores alternan turnos. </li><li> En cada turno, el jugador puede tomar 1 o 2 piedras de la pila central </li><li> Los dos jugadores continúan hasta que la pila central se ha quedado sin piedras. </li></ol> El último jugador en tomar una piedra pierde. Aquí hay una captura de pantalla de un ejemplo de ejecución: <center><img src="{{pathToRoot}}img/projects/nimm/nimm.png" style="width:500px"/><p style="text-align:center"></p></center></p><p> Escribe un programa para jugar a Nimm. Para hacer tu vida más fácil, hemos dividido el problema en retos más pequeños. Tienes mucho tiempo para este programa. Tómalo despacio, parte por parte. </p></div></div><div class="row"><div class="col-md-12"><h2> Reto 1 </h2><p> Comienza con 20 piedras. Repite el proceso de quitar piedras e imprimir cuántas piedras quedan hasta que no queden más. No te preocupes por saber de quién es el turno. No te preocupes por asegurarte de que solo se eliminen una o dos piedras. Usa el método <code>leerInt(<i>mensaje</i>)</code> que imprime mensaje y espera a que el usuario ingrese un número. </p><center><img src="{{pathToRoot}}img/projects/nimm/nimm_m1.png" style="width:500px"/></center></div></div><div class="row"><div class="col-md-12"><h2> Reto 2 </h2><p> Crea una variable de tipo <code>int</code> para realizar un seguimiento de quién es el turno (recuerda que hay dos jugadores). Dile al usuario de quién es el turno. Cada vez que alguien termine su turno, cambia el número del jugador. </p><center><img src="{{pathToRoot}}img/projects/nimm/nimm_m2.png" style="width:500px"/></center></div></div><div class="row"><div class="col-md-12"><h2> Reto 3 </h2><p> Asegúrate de que en cada turno solo se tomen una o dos piedras. Después de leer el número de piedras para tomar (su entrada), puede usar el siguiente patrón para verificar si era válido y seguir preguntando hasta que sea válido. </p><div class="well"><code>while(<i>entrada is inválida</i>) { <br/>&nbsp;&nbsp;&nbsp;<i>entrada</i> = leerInt(&quot;Por favor ingrese 1 o 2: &quot;); <br/>}</code></div></div></div></body><div class="row"><div class="col-md-12"><h2> Reto 4 </h2><p> Anuncia el ganador. </p></div></div><div class="row"><div class="col-md-12"><h2> Extensiones: </h2><p>¿Puedes escribir un oponente inteligente? Puedes comenzar con una IA ficticia que siempre imprime un número aleatorio. Luego trata de hacer uno que juegue inteligentemente... </p><p> Algunas otras ideas de extensión: </p><ul><li> Asegúrate de que si solo queda una piedra, el último jugador solo pueda quitar una piedra. </li><li> Ofrece al usuario la opción de que el ganador sea el jugador que no tome la última piedra o el jugador que tome la última piedra. </li><li> Expande el juego para permitir que los jugadores tomen 1, 2 o 3 piedras por turno. </li><li> Regla "divisible por 3": si el número de piedras que quedan al final del turno de un jugador es divisible por 3, deben volver a jugar. </li><li> Ofrece al usuario la opción de jugar contra la computadora y diseñar un proceso para que la computadora elija la cantidad de piedras que eliminará. </li><li> Crea tu propia extensión. </li></ul></div></div><!--<div class="row">
			<div class="col-md-12">
				<h2>Solution</h2>


<pre id="editor" style="height:580px">/**
 * Carbon Dating
 * -------------
 * This program shows how to translate between percent of natural carbon-14 found
 * in a sample. First, it prints out a carbon-14 (c14) lookup table, then it has users
 * enter a percent of c14 and returns the expected age. 
 */
public class CarbonDating extends ProgramaDeConsola {
	
	private static final int HALF_LIFE = 5700;
	
	public void run() {
		// 1. Show the c-14 lookup table
		double percent = 100.0;
		int elapsed = 0;
		println("Carbon dating lookup table");
		println("fraction C-14 remaining:  years passed");
		println("--------------------------");
		for(int i = 0; i &lt; 10; i++) {
			println(percent + "%:  " + elapsed + " years");
			elapsed += HALF_LIFE;
			percent /= 2;
		}
		println("");
		
		// 2. Look up the age of a sample
		while(true) {
			double percentLeft = leerDoble("What percent of natural carbon-14 does your sample have? ");
			double years = HALF_LIFE * Math.log(percentLeft / 100.0) / Math.log(0.5);
			println(percentLeft + "% carbon-14 left...");
			println("The sample is " + years + " years old");
			println("");
		}
	}
}
</pre>
    
<script src="{{pathToRoot}}plugins/ace/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
    var editor = ace.edit("editor");
   editor.setTheme('ace/theme/eclipse');
   editor.getSession().setMode("ace/mode/java");
   editor.setReadOnly(true);
   editor.setShowPrintMargin(false);
   editor.renderer.setShowGutter(false); 
    /*editor.setTheme("ace/theme/eclipse");
    editor.getSession().setMode("ace/mode/java");*/
</script>
	</div>
	</div>-->
		
		%include templates/parts/footer.html
<script data-main="gameOfStones.js" src="js/requirejs/require.js"></script>